# -*- coding: utf-8 -*-
"""github_UFCpoststats.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17kbn9CHpnxsGqz6PZMdVb089s6ar-1oL
"""

import pandas as pd
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import seaborn as sns
import requests
import base64
import json
from datetime import datetime

# Load and analyze betting data
dfpost = pd.read_csv("https://raw.githubusercontent.com/zwinship/UFC_Model/refs/heads/main/results/all_betting_results.csv")


# Basic statistics
profit_stats = {
    'count': len(dfpost),
    'mean': dfpost['profit'].mean(),
    'median': dfpost['profit'].median(),
    'std': dfpost['profit'].std(),
    'min': dfpost['profit'].min(),
    'max': dfpost['profit'].max(),
    'range': dfpost['profit'].max() - dfpost['profit'].min(),
    'iqr': dfpost['profit'].quantile(0.75) - dfpost['profit'].quantile(0.25)
}

print("Basic Statistics:")
for stat, value in profit_stats.items():
    print(f"{stat}: {value}")

# One-sample t-test to check if profit is significantly greater than 0.96 (changed from 1.0)
t_stat, p_value = stats.ttest_1samp(dfpost['profit'], 0.96)

# Since we want to test if it's greater than 0.96 (not just different from 0.96),
# we need to convert the two-sided p-value to a one-sided p-value
p_value_one_sided = p_value / 2 if t_stat > 0 else 1 - (p_value / 2)

print("\nOne-sample t-test (H0: profit = 0.96, H1: profit > 0.96)")
print(f"t-statistic: {t_stat}")
print(f"p-value (one-sided): {p_value_one_sided}")
print(f"Conclusion: {'Reject H0' if p_value_one_sided < 0.05 else 'Fail to reject H0'}")

# Convert statistical results to JSON for GitHub export
stats_results = {
    "basic_statistics": profit_stats,
    "t_test": {
        "null_hypothesis_value": 0.96,  # Changed from 1.0
        "t_statistic": float(t_stat),
        "p_value_one_sided": float(p_value_one_sided),
        "conclusion": "Reject H0" if p_value_one_sided < 0.05 else "Fail to reject H0"
    },
    "analysis_date": datetime.now().strftime('%Y-%m-%d %H:%M:%S')
}

# Convert to JSON string
stats_json = json.dumps(stats_results, indent=4)

# GitHub API parameters
github_token = "ohnepixel"  # You should regenerate this token for security
repo_owner = "zwinship"
repo_name = "UFC_Model"


def upload_to_github(content, file_path, commit_message):
    """
    Generic function to upload content to GitHub
    """
    # Encode content to base64
    content_encoded = base64.b64encode(content.encode()).decode()

    # GitHub API endpoint
    url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{file_path}"

    # Headers for authentication
    headers = {
        "Authorization": f"token {github_token}",
        "Accept": "application/vnd.github.v3+json"
    }

    # Data for the API request
    data = {
        "message": commit_message,
        "content": content_encoded
    }

    # Check if file exists
    check_response = requests.get(url, headers=headers)

    if check_response.status_code == 200:
        # File exists, get the SHA to ensure it's overwritten
        file_sha = check_response.json()['sha']
        data['sha'] = file_sha
        print(f"Updating existing file: {file_path}")
    else:
        print(f"Creating new file: {file_path}")

    # Send the request to update the file
    response = requests.put(url, headers=headers, json=data)

    if response.status_code == 201:
        print(f"File created: {file_path}")
    elif response.status_code == 200:
        print(f"File updated: {file_path}")
    else:
        print(f"Error: {response.status_code}")
        print(response.json())

    return response.status_code in (200, 201)


# UPLOAD #1: JSON VERSION FOR EASY QUERYING
json_file_path = "statistics/ufc_statistical_analysis.json"
json_commit_message = f"Update UFC statistical analysis JSON {datetime.now().strftime('%Y-%m-%d')}"
upload_to_github(stats_json, json_file_path, json_commit_message)


# UPLOAD #2: MARKDOWN VERSION FOR READABILITY
# Create a readable markdown report with more context about the Return to Player (RTP) model
markdown_content = f"""# UFC Betting Model Return to Player Analysis

*Analysis Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*

## Overview
This analysis evaluates the Return to Player (RTP) performance of our UFC betting model. The RTP metric represents the percentage of wagered money returned to bettors, where values greater than 96% indicate profitable bets after accounting for typical sportsbook margins (e.g., a value of 120% means a 20% profit on investment).

## Basic Statistics on Model RTP

| Metric | Value | Interpretation |
|--------|-------|----------------|
| Count | {profit_stats['count']} | Number of bets analyzed |
| Mean | {profit_stats['mean']:.4f} | Average RTP multiple (>0.96 means profitable) |
| Median | {profit_stats['median']:.4f} | Middle RTP value (less affected by outliers) |
| Standard Deviation | {profit_stats['std']:.4f} | Measure of RTP volatility |
| Minimum | {profit_stats['min']:.4f} | Lowest RTP (biggest loss) |
| Maximum | {profit_stats['max']:.4f} | Highest RTP (biggest win) |
| Range | {profit_stats['range']:.4f} | Difference between highest and lowest RTP |
| Interquartile Range | {profit_stats['iqr']:.4f} | Range of the middle 50% of RTP values |

## Statistical Significance Testing

### One-sample t-test
- **Null Hypothesis (H₀)**: The model's average RTP is equal to 0.96 (break-even after sportsbook margin)
- **Alternative Hypothesis (H₁)**: The model's average RTP is greater than 0.96 (profitable after sportsbook margin)

### Results
- **t-statistic**: {t_stat:.4f}
- **p-value (one-sided)**: {p_value_one_sided:.4f}
- **Conclusion**: {'Reject H₀' if p_value_one_sided < 0.05 else 'Fail to reject H₀'}

### What This Means
"""

# Add the conditional text separately to avoid backslash issues in f-strings
if p_value_one_sided < 0.05:
    markdown_content += """**The model is statistically profitable!** With a p-value less than 0.05, we have sufficient evidence to conclude that our betting model performs significantly better than the 96% threshold needed to overcome the typical bookmaker margin. The RTP observed is unlikely to be due to random chance, suggesting our model has genuine predictive power for UFC fights."""
else:
    markdown_content += """**The results are inconclusive.** While the model may show some profitability, we don't have enough statistical evidence to conclude that it performs better than the 96% threshold needed to overcome typical bookmaker margins. The observed RTP might be due to random chance rather than genuine predictive power."""

markdown_content += f"""

## RTP Distribution
The mean RTP of {profit_stats['mean']:.4f}x indicates that on average, each 1 unit bet returns {profit_stats['mean']:.2f} units. For comparison, a random selection strategy would be expected to return approximately $0.96 per $1 bet in the long run (due to bookmaker margins).

## Dataset Information
This analysis was performed on the UFC Model betting results dataset, which includes {profit_stats['count']} bets. The model's predictions were compared against actual fight outcomes to evaluate RTP performance.

## Conclusion
"""

# Add the conditional conclusion separately to avoid backslash issues
if p_value_one_sided < 0.05:
    markdown_content += """Based on statistical testing, we can confidently say this betting model has an edge over bookmakers and delivers a Return to Player that performs better than random selection would."""
else:
    markdown_content += """While showing promise, we need more data to determine if this betting model truly outperforms bookmaker odds and random selection in terms of Return to Player."""

# Upload the markdown file to GitHub
markdown_file_path = "statistics/ufc_statistical_analysis.md"
markdown_commit_message = f"Update UFC statistical analysis report {datetime.now().strftime('%Y-%m-%d')}"
upload_to_github(markdown_content, markdown_file_path, markdown_commit_message)



import sys
sys.exit(0)